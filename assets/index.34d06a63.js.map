{"version":3,"file":"index.34d06a63.js","sources":["../../node_modules/.pnpm/ahooks@3.1.13_react@17.0.2/node_modules/ahooks/es/useUpdateEffect/index.js","../../node_modules/.pnpm/@use-gesture+core@10.2.10/node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js","../../node_modules/.pnpm/@use-gesture+core@10.2.10/node_modules/@use-gesture/core/dist/actions-8fb255d4.esm.js","../../node_modules/.pnpm/@use-gesture+core@10.2.10/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","../../node_modules/.pnpm/@use-gesture+react@10.2.10_react@17.0.2/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/utils/dev-log.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/utils/is-dev.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/page-indicator/page-indicator.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/page-indicator/index.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/swiper/swiper-item.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/swiper/swiper.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/swiper/index.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/utils/use-ref-state.js","../../src/pages/Recommend/index.tsx"],"sourcesContent":["import { useEffect } from 'react';\nimport { createUpdateEffect } from '../createUpdateEffect';\nexport default createUpdateEffect(useEffect);","function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-b2a210f4.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (capture ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  const dx = P2.clientX - P1.clientX;\n  const dy = P2.clientY - P1.clientY;\n  const cx = (P2.clientX + P1.clientX) / 2;\n  const cy = (P2.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n\n      V.addTo(state._distance, _absoluteDelta);\n    }\n\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n\n    if (this.intent) this.intent(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n      }\n    }\n  }\n\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n\n}\n\nfunction selectAxis([dx, dy]) {\n  const d = Math.abs(dx) - Math.abs(dy);\n  if (d > 0) return 'x';\n  if (d < 0) return 'y';\n  return undefined;\n}\n\nfunction restrictVectorToAxis(v, axis) {\n  switch (axis) {\n    case 'x':\n      v[1] = 0;\n      break;\n\n    case 'y':\n      v[0] = 0;\n      break;\n  }\n}\n\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n\n  intent(v) {\n    this.state.axis = this.state.axis || selectAxis(v);\n    this.state._blocked = (this.config.lockDirection || !!this.config.axis) && !this.state.axis || !!this.config.axis && this.config.axis !== this.state.axis;\n    if (this.state._blocked) return;\n\n    if (this.config.axis || this.config.lockDirection) {\n      restrictVectorToAxis(v, this.state.axis);\n    }\n  }\n\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n\n  preventDefault(value = false) {\n    return value;\n  },\n\n  triggerAllEvents(value = false) {\n    return value;\n  },\n\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return V.toVector(value);\n    }\n  },\n\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n\n        return r;\n      };\n    }\n\n    return transform || identity;\n  },\n\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n\n};\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n\n      return NaN;\n    },\n\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n\n      return NaN;\n    },\n\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n\n    if ('current' in value) {\n      return () => value.current;\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n\n});\n\nconst DISPLACEMENT = 10;\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n\n  setup() {\n    const state = this.state;\n\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    this.ctrl.setEventIds(event);\n\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n\n    if (state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n\n    if (config.preventScrollAxis) {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n\n    const _values = pointerValues(event);\n\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerClick(event) {\n    if (!this.state.tap) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  setupScrollPrevention(event) {\n    persistEvent(event);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', this.clean.bind(this));\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', this.clean.bind(this));\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      state._delta = deltaFn(factor);\n      this.start(event);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n\n    bindFunction('key', 'down', this.keyDown.bind(this));\n    bindFunction('key', 'up', this.keyUp.bind(this));\n\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n\n}\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n\n});\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'pinching');\n\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n\n  intent(v) {\n    const state = this.state;\n\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(v[0]) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(v[1]);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n\n    if (this.config.lockDirection) {\n      if (state.axis === 'scale') v[1] = 0;else if (state.axis === 'angle') v[0] = 0;\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n\n    if (!state._active) return;\n\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  wheel(event) {\n    if (!event.ctrlKey) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    } else {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  }\n\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    const [ox, oy] = state.overflow;\n    const [dx, dy] = state._delta;\n    const [dirx, diry] = state._direction;\n\n    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n      state._movement[0] = state._movementBound[0];\n    }\n\n    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n      state._movement[1] = state._movementBound[1];\n    }\n\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-8fb255d4.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n\n    return undefined;\n  },\n\n  enabled(value = true) {\n    return value;\n  },\n\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n\n  transform(value) {\n    return value;\n  }\n\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\nfunction parse(config, gestureKey) {\n  const _ref = config,\n        {\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n  const _config = {\n    shared: resolveWith({\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl) {\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  add(element, device, action, handler, options) {\n    const type = toDomEventType(device, action);\n\n    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n    element.addEventListener(type, handler, eventOptions);\n\n    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));\n  }\n\n  clean() {\n    this._listeners.forEach(remove => remove());\n\n    this._listeners = [];\n  }\n\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n\n    if (timeout) window.clearTimeout(timeout);\n  }\n\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n\n    this._timeouts.clear();\n  }\n\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n    }\n  }\n\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey);\n  }\n\n  clean() {\n    this._targetEventStore.clean();\n\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const eventOptions = sharedConfig.eventOptions;\n    const props = {};\n    let target;\n\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n\n    const bindFunction = bindToProps(props, eventOptions, !!target);\n\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        if (this.config[gestureKey].enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n\n      for (const eventKey in this.nativeHandlers) {\n        bindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n\n    if (!target) return props;\n\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n\n}\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n\n    return;\n  }\n\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n\n  return undefined;\n}\n\nfunction useDrag(handler, config = {}) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config, 'drag');\n}\n\nfunction usePinch(handler, config = {}) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config, 'pinch');\n}\n\nfunction useWheel(handler, config = {}) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config, 'wheel');\n}\n\nfunction useScroll(handler, config = {}) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config, 'scroll');\n}\n\nfunction useMove(handler, config = {}) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config, 'move');\n}\n\nfunction useHover(handler, config = {}) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config = {}) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config);\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config = {}) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config);\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n","import { isDev } from './is-dev';\nexport function devWarning(component, message) {\n  if (isDev) {\n    console.warn(`[antd-mobile: ${component}] ${message}`);\n  }\n}\nexport function devError(component, message) {\n  if (isDev) {\n    console.error(`[antd-mobile: ${component}] ${message}`);\n  }\n}","export const isDev = process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';","import React, { memo } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport classNames from 'classnames';\nimport { mergeProps } from '../../utils/with-default-props';\nconst classPrefix = `adm-page-indicator`;\nconst defaultProps = {\n  color: 'primary',\n  direction: 'horizontal'\n};\nexport const PageIndicator = memo(p => {\n  const props = mergeProps(defaultProps, p);\n  const dots = [];\n\n  for (let i = 0; i < props.total; i++) {\n    dots.push(React.createElement(\"div\", {\n      key: i,\n      className: classNames(`${classPrefix}-dot`, {\n        [`${classPrefix}-dot-active`]: props.current === i\n      })\n    }));\n  }\n\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: classNames(classPrefix, `${classPrefix}-${props.direction}`, `${classPrefix}-color-${props.color}`)\n  }, dots));\n});","import \"./page-indicator.css\";\nimport { PageIndicator } from './page-indicator';\nexport default PageIndicator;","import React from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nexport const SwiperItem = props => {\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: 'adm-swiper-item',\n    onClick: props.onClick\n  }, props.children));\n};","import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect, useUpdateEffect } from 'ahooks';\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true\n};\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n\n  return () => {\n    let loop = props.loop;\n\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n\n    const trackRef = useRef(null);\n\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n\n    const [current, setCurrent] = useState(props.defaultIndex);\n    useUpdateEffect(() => {\n      var _a;\n\n      (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, current);\n    }, [current]);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n\n      return bound(current, min, max);\n    }\n\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const bind = useDrag(state => {\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: ([x, y]) => [-x, -y],\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n\n    function swipeTo(index, immediate = false) {\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      const interval = window.setInterval(() => {\n        swipeNext();\n      }, autoplayInterval);\n      return () => {\n        window.clearInterval(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging]);\n\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: 'adm-swiper-track-inner'\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: 'adm-swiper-slide',\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: 'adm-swiper-track-inner',\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(\"div\", {\n            className: 'adm-swiper-slide'\n          }, child);\n        }));\n      }\n    }\n\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames('adm-swiper', `adm-swiper-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames('adm-swiper-track', {\n        'adm-swiper-track-allow-touch-move': props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n      }\n    }, props.allowTouchMove ? bind() : {}), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: 'adm-swiper-indicator'\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\n\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}","import \"./swiper.css\";\nimport { Swiper } from './swiper';\nimport { attachPropertiesToComponent } from '../../utils/attach-properties-to-component';\nimport { SwiperItem } from './swiper-item';\nexport default attachPropertiesToComponent(Swiper, {\n  Item: SwiperItem\n});","import { useEffect, useRef, useState } from 'react';\nexport function useRefState(initialState) {\n  const [state, setState] = useState(initialState);\n  const ref = useRef(state);\n  useEffect(() => {\n    ref.current = state;\n  }, [state]);\n  return [state, setState, ref];\n}","import React, { FC, useCallback, useEffect, useRef, useState } from \"react\";\nimport { getAlbumDetailRequest, getBannerRequest, getHotList } from \"@/services/comment\";\nimport { Image, Swiper } from \"antd-mobile\";\nimport { BannerList, SongList } from \"@/pages/Recommend/types\";\nimport styles from \"./recommend.module.scss\";\nimport { Outlet, useNavigate } from \"react-router-dom\";\nimport Scroll from \"@/components/Scroll\";\nimport { useAppDispatch } from \"@/store\";\nimport { changeCurrentIndex, changePlayList, changeSequencePlayList } from \"@/store/playerSlice\";\nimport Loading from \"@/components/Loading\";\n\ninterface Props {\n  name?: string;\n}\n\nconst Recommend: FC<Props> = props => {\n  const [bannerList, setBannerList] = useState<BannerList[]>([]);\n  const [hotList, setHotList] = useState<SongList[]>([]);\n  const [hotSongList, setHotSongList] = useState<SongList[]>([]);\n\n  const navigate = useNavigate();\n\n  const [enterLoading, setEnterLoading] = useState(true);\n\n  useEffect(() => {\n    getBannerRequest()\n      .then((data: { banners: BannerList[] }) => {\n        const { banners } = data;\n        setBannerList(banners);\n      })\n      .catch((e: unknown) => {\n        console.log(e);\n      });\n    getHotList({\n      limit: 10\n    })\n      .then((data: { result: SongList[] }) => {\n        const { result } = data;\n        setHotList(result);\n      })\n      .catch((e: unknown) => {\n        console.log(e);\n      });\n    return () => {\n      setBannerList([]);\n      setHotList([]);\n    };\n  }, []);\n  useEffect(() => {\n    if (hotList.length === 0) return;\n    getAlbumDetailRequest(hotList[0]?.id as number)\n      .then((data: { playlist: { tracks: any } }) => {\n        const { playlist } = data;\n        setHotSongList(playlist.tracks);\n        setEnterLoading(false);\n      })\n      .catch((e: unknown) => {\n        console.log(e);\n      });\n\n    return () => {\n      setHotSongList([]);\n    };\n  }, [hotList]);\n\n  const dispatch = useAppDispatch();\n  const categoryRef = useRef<any>();\n\n  useEffect(() => {\n    const Dom = categoryRef.current;\n    const tagElems = Dom.querySelectorAll(\"li\");\n    let totalWidth = 0;\n    tagElems.forEach((ele: any) => {\n      totalWidth += ele.offsetWidth + 8;\n    });\n    Dom.style.width = `${totalWidth - 8}px`;\n  }, [hotList]);\n\n  return (\n    <>\n      <div\n        style={{\n          width: \"100%\",\n          height: \"100%\",\n          overflow: \"hidden\"\n        }}\n      >\n        <Scroll bounceTop={true}>\n          <div>\n            <section>\n              <Swiper\n                style={{\n                  height: \"140px\"\n                }}\n                autoplay\n                loop\n              >\n                {bannerList?.map((value, index) => {\n                  return (\n                    <Swiper.Item key={index}>\n                      <div\n                        className={\"swiperItem\"}\n                        onClick={() => {\n                          // TODO \n                          console.log(value.typeTitle);\n                        }}\n                      >\n                        <Image src={value.imageUrl} alt={value.typeTitle} />\n                      </div>\n                    </Swiper.Item>\n                  );\n                })}\n              </Swiper>\n            </section>\n            <section>\n              <h1 className={styles.title}></h1>\n              <Scroll direction={\"horizontal\"}>\n                <ul ref={categoryRef} className={styles.songListWrapper}>\n                  {hotList?.map(value => {\n                    return (\n                      <li\n                        className={styles.songList}\n                        key={value.id}\n                        onClick={() => {\n                          navigate(`./${value.id}`);\n                        }}\n                      >\n                        <Image\n                          lazy\n                          src={`${value.picUrl}?param=150y150`}\n                          style={{ width: 105, height: 105 }}\n                        />\n                        <p>{value.name}</p>\n                      </li>\n                    );\n                  })}\n                </ul>\n              </Scroll>\n            </section>\n            <section>\n              <h1 className={styles.tuneListTitle}></h1>\n              {hotSongList?.map((value: any, index) => {\n                return (\n                  <div\n                    className={styles.tuneList}\n                    key={value.id}\n                    id={String(value.id)}\n                    onClick={e => {\n                      e.preventDefault();\n                      // const id = Number(e.currentTarget.id);\n                      // goToId(id);\n                      dispatch(changePlayList(hotSongList));\n                      dispatch(changeCurrentIndex(index));\n                      dispatch(changeSequencePlayList(hotSongList));\n                    }}\n                  >\n                    <p className={styles.tuneListLeft}>\n                      <span>{index + 1}</span>\n                      <span>{value.name}</span>\n                    </p>\n                    <div className={styles.tuneListRight}>{value?.ar[0].name}</div>\n                  </div>\n                );\n              })}\n            </section>\n          </div>\n        </Scroll>\n        {enterLoading ? <Loading /> : null}\n      </div>\n    </>\n  );\n};\nexport default Recommend;\n"],"names":["useUpdateEffect","createUpdateEffect","useEffect","V","toVector","v","fallback","Array","isArray","add","v1","v2","sub","addTo","subTo","rubberband","distance","dimension","constant","Infinity","Math","abs","pow","rubberbandIfOutOfBounds","position","min","max","clamp","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","EVENT_TYPE_MAP","pointer","start","change","end","mouse","touch","gesture","capitalize","string","toUpperCase","slice","pointerCaptureEvents","parseProp","prop","eventKey","substring","toLowerCase","passive","indexOf","replace","captureKey","includes","capture","device","isTouch","event","getValueEvent","type","changedTouches","targetTouches","getTouchList","touchIds","from","touches","e","_event$currentTarget","_event$currentTarget$","currentTarget","contains","call","getCurrentTargetTouchList","map","identifier","pointerId","valueEvent","pointerValues","clientX","clientY","args","noop","chain","fns","result","fn","this","assignDefault","assign","identity","commonConfigResolver","enabled","preventDefault","triggerAllEvents","transform","_k","config","shared","hasCustomTransform","threshold","coordinatesConfigResolver","axis","_v","lockDirection","bounds","state","current","HTMLElement","left","right","top","bottom","KEYS_DELTA_MAP","ArrowRight","factor","ArrowLeft","ArrowUp","ArrowDown","isBrowser","window","document","createElement","isTouchScreen","navigator","maxTouchPoints","SUPPORT","GestureEvent","supportsGestureEvents","touchscreen","pointerLock","dragConfigResolver","lock","preventScrollAxis","preventScroll","preventScrollDelay","pointerCapture","buttons","pointerButtons","filterTaps","tapsThreshold","swipe","velocity","duration","delay","scaleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","mouseOnly","EngineMap","Map","ConfigResolverMap","dragAction","engine","constructor","ctrl","computeValues","computeInitial","init","reset","eventStore","gestureEventStores","timeoutStore","gestureTimeoutStores","sharedConfig","handler","handlers","ingKey","_active","active","_blocked","_force","_step","intentional","_movement","_distance","_direction","_delta","_bounds","memo","elapsedTime","direction","overflow","_movementBound","movement","delta","timeStamp","lastOffset","offset","startTime","values","_values","_initial","initial","compute","dt","cancelable","pointerIds","size","locked","pointerLockElement","payload","shiftKey","altKey","metaKey","ctrlKey","getEventDetails","down","pressed","_absoluteDelta","_m0","_m1","t0","t1","sign","v0","intent","previousOffset","gestureIsActive","first","last","setup","computeOffset","ox","oy","x0","x1","y0","y1","rubberband2","Vx","Vy","Rx","Ry","X0","X1","Y0","Y1","computeRubberband","computeMovement","absoluteDelta","emit","clean","aliasKey","super","dx","dy","d","selectAxis","restrictVectorToAxis","_pointerId","_pointerActive","_keyboardActive","_preventScroll","_delayed","tap","canceled","cancel","bind","boundRect","getBoundingClientRect","targetRect","setTimeout","setActive","pointerClean","pointerDown","setEventIds","setPointerCapture","setupPointer","setupScrollPrevention","setupDelayTrigger","startPointerDrag","pointerMove","id","movementX","movementY","remove","pointerUp","hasPointerCapture","releasePointerCapture","_unused","dirx","diry","vx","vy","mx","my","svx","svy","sx","sy","sdt","pointerClick","stopPropagation","requestPointerLock","exitPointerLock","persist","persistEvent","keyDown","deltaFn","keyUp","bindFunction","resolver","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","prototype","propertyIsEnumerable","sharedConfigResolver","eventOptions","_excluded","resolveWith","resolvers","entries","EventStore","_ctrl","element","action","options","deviceProps","toDomEventType","addEventListener","_listeners","removeEventListener","TimeoutStore","callback","ms","_timeouts","set","timeout","get","clearTimeout","clear","Controller","Set","internalHandlers","drag","setupGesture","wheel","scroll","move","pinch","hover","resolveGestures","delete","applyHandlers","nativeHandlers","applyConfig","gestureKey","_ref","window2","rest","_config","parse","_targetEventStore","gestures","effect","props","bindToProps","handlerProp","withPassiveOption","isNative","_options$capture","_options$passive","actionKey","toHandlerProp","useDrag","React","useMemo","useRecognizers","devWarning","component","message","classPrefix","defaultProps","color","PageIndicator","exports","p","mergeProps","dots","total","className","classNames","withNativeProps","SwiperItem","onClick","children","defaultIndex","allowTouchMove","autoplay","autoplayInterval","loop","slideSize","trackOffset","stuckAtBoundary","modulus","division","remainder","Swiper","attachPropertiesToComponent","forwardRef","staged","ref","isVertical","slideRatio","offsetRatio","validChildren","count","count2","Children","child","isValidElement","trackRef","useRef","getSlidePixels","track","offsetHeight","offsetWidth","setCurrent","useState","_a","onIndexChange","dragging","setDragging","draggingRef","initialState","setState","useRefState","boundIndex","current2","bound","api","useSpring","tension","friction","onRest","rawX","standardPosition","immediate","slidePixels","paramIndex","minIndex","floor","maxIndex","index","round","swipeTo","x","y","lowerBound","upperBound","roundedIndex","targetIndex","swipeNext","swipePrev","react","useImperativeHandle","useIsomorphicLayoutEffect","interval","setInterval","clearInterval","style","onClickCapture","animated","div","to","position2","finalPosition","totalWidth","flagWidth","indicator","indicatorProps","Item","Recommend","bannerList","setBannerList","hotList","setHotList","hotSongList","setHotSongList","navigate","useNavigate","enterLoading","setEnterLoading","getBannerRequest","then","data","banners","catch","getHotList","limit","getAlbumDetailRequest","playlist","tracks","dispatch","useAppDispatch","categoryRef","Dom","tagElems","querySelectorAll","ele","width","height","Scroll","bounceTop","Image","src","imageUrl","alt","typeTitle","styles","lazy","picUrl","name","String","changePlayList","changeCurrentIndex","changeSequencePlayList","ar","Loading"],"mappings":"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"}