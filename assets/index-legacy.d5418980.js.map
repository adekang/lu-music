{"version":3,"file":"index-legacy.d5418980.js","sources":["../../node_modules/.pnpm/ahooks@3.1.13_react@17.0.2/node_modules/ahooks/es/useUpdateEffect/index.js","../../node_modules/.pnpm/@use-gesture+core@10.2.10/node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js","../../node_modules/.pnpm/@use-gesture+core@10.2.10/node_modules/@use-gesture/core/dist/actions-8fb255d4.esm.js","../../node_modules/.pnpm/@use-gesture+core@10.2.10/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","../../node_modules/.pnpm/@use-gesture+react@10.2.10_react@17.0.2/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/utils/dev-log.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/utils/is-dev.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/page-indicator/page-indicator.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/page-indicator/index.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/swiper/swiper-item.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/swiper/swiper.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/utils/use-ref-state.js","../../node_modules/.pnpm/antd-mobile@5.3.0_react-dom@17.0.2+react@17.0.2/node_modules/antd-mobile/es/components/swiper/index.js","../../src/pages/Recommend/index.tsx"],"sourcesContent":["import { useEffect } from 'react';\nimport { createUpdateEffect } from '../createUpdateEffect';\nexport default createUpdateEffect(useEffect);","function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-b2a210f4.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (capture ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  const dx = P2.clientX - P1.clientX;\n  const dy = P2.clientY - P1.clientY;\n  const cx = (P2.clientX + P1.clientX) / 2;\n  const cy = (P2.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n\n      V.addTo(state._distance, _absoluteDelta);\n    }\n\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n\n    if (this.intent) this.intent(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n      }\n    }\n  }\n\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n\n}\n\nfunction selectAxis([dx, dy]) {\n  const d = Math.abs(dx) - Math.abs(dy);\n  if (d > 0) return 'x';\n  if (d < 0) return 'y';\n  return undefined;\n}\n\nfunction restrictVectorToAxis(v, axis) {\n  switch (axis) {\n    case 'x':\n      v[1] = 0;\n      break;\n\n    case 'y':\n      v[0] = 0;\n      break;\n  }\n}\n\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n\n  intent(v) {\n    this.state.axis = this.state.axis || selectAxis(v);\n    this.state._blocked = (this.config.lockDirection || !!this.config.axis) && !this.state.axis || !!this.config.axis && this.config.axis !== this.state.axis;\n    if (this.state._blocked) return;\n\n    if (this.config.axis || this.config.lockDirection) {\n      restrictVectorToAxis(v, this.state.axis);\n    }\n  }\n\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n\n  preventDefault(value = false) {\n    return value;\n  },\n\n  triggerAllEvents(value = false) {\n    return value;\n  },\n\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return V.toVector(value);\n    }\n  },\n\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n\n        return r;\n      };\n    }\n\n    return transform || identity;\n  },\n\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n\n};\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n\n      return NaN;\n    },\n\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n\n      return NaN;\n    },\n\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n\n    if ('current' in value) {\n      return () => value.current;\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n\n});\n\nconst DISPLACEMENT = 10;\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n\n  setup() {\n    const state = this.state;\n\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    this.ctrl.setEventIds(event);\n\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n\n    if (state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n\n    if (config.preventScrollAxis) {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n\n    const _values = pointerValues(event);\n\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerClick(event) {\n    if (!this.state.tap) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  setupScrollPrevention(event) {\n    persistEvent(event);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', this.clean.bind(this));\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', this.clean.bind(this));\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      state._delta = deltaFn(factor);\n      this.start(event);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n\n    bindFunction('key', 'down', this.keyDown.bind(this));\n    bindFunction('key', 'up', this.keyUp.bind(this));\n\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n\n}\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n\n});\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'pinching');\n\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n\n  intent(v) {\n    const state = this.state;\n\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(v[0]) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(v[1]);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n\n    if (this.config.lockDirection) {\n      if (state.axis === 'scale') v[1] = 0;else if (state.axis === 'angle') v[0] = 0;\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n\n    if (!state._active) return;\n\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  wheel(event) {\n    if (!event.ctrlKey) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    } else {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  }\n\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    const [ox, oy] = state.overflow;\n    const [dx, dy] = state._delta;\n    const [dirx, diry] = state._direction;\n\n    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n      state._movement[0] = state._movementBound[0];\n    }\n\n    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n      state._movement[1] = state._movementBound[1];\n    }\n\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-8fb255d4.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n\n    return undefined;\n  },\n\n  enabled(value = true) {\n    return value;\n  },\n\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n\n  transform(value) {\n    return value;\n  }\n\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\nfunction parse(config, gestureKey) {\n  const _ref = config,\n        {\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n  const _config = {\n    shared: resolveWith({\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl) {\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  add(element, device, action, handler, options) {\n    const type = toDomEventType(device, action);\n\n    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n    element.addEventListener(type, handler, eventOptions);\n\n    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));\n  }\n\n  clean() {\n    this._listeners.forEach(remove => remove());\n\n    this._listeners = [];\n  }\n\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n\n    if (timeout) window.clearTimeout(timeout);\n  }\n\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n\n    this._timeouts.clear();\n  }\n\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n    }\n  }\n\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey);\n  }\n\n  clean() {\n    this._targetEventStore.clean();\n\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const eventOptions = sharedConfig.eventOptions;\n    const props = {};\n    let target;\n\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n\n    const bindFunction = bindToProps(props, eventOptions, !!target);\n\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        if (this.config[gestureKey].enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n\n      for (const eventKey in this.nativeHandlers) {\n        bindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n\n    if (!target) return props;\n\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n\n}\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n\n    return;\n  }\n\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n\n  return undefined;\n}\n\nfunction useDrag(handler, config = {}) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config, 'drag');\n}\n\nfunction usePinch(handler, config = {}) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config, 'pinch');\n}\n\nfunction useWheel(handler, config = {}) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config, 'wheel');\n}\n\nfunction useScroll(handler, config = {}) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config, 'scroll');\n}\n\nfunction useMove(handler, config = {}) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config, 'move');\n}\n\nfunction useHover(handler, config = {}) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config = {}) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config);\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config = {}) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config);\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n","import { isDev } from './is-dev';\nexport function devWarning(component, message) {\n  if (isDev) {\n    console.warn(`[antd-mobile: ${component}] ${message}`);\n  }\n}\nexport function devError(component, message) {\n  if (isDev) {\n    console.error(`[antd-mobile: ${component}] ${message}`);\n  }\n}","export const isDev = process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test';","import React, { memo } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport classNames from 'classnames';\nimport { mergeProps } from '../../utils/with-default-props';\nconst classPrefix = `adm-page-indicator`;\nconst defaultProps = {\n  color: 'primary',\n  direction: 'horizontal'\n};\nexport const PageIndicator = memo(p => {\n  const props = mergeProps(defaultProps, p);\n  const dots = [];\n\n  for (let i = 0; i < props.total; i++) {\n    dots.push(React.createElement(\"div\", {\n      key: i,\n      className: classNames(`${classPrefix}-dot`, {\n        [`${classPrefix}-dot-active`]: props.current === i\n      })\n    }));\n  }\n\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: classNames(classPrefix, `${classPrefix}-${props.direction}`, `${classPrefix}-color-${props.color}`)\n  }, dots));\n});","import \"./page-indicator.css\";\nimport { PageIndicator } from './page-indicator';\nexport default PageIndicator;","import React from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nexport const SwiperItem = props => {\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: 'adm-swiper-item',\n    onClick: props.onClick\n  }, props.children));\n};","import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect, useUpdateEffect } from 'ahooks';\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true\n};\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n\n  return () => {\n    let loop = props.loop;\n\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n\n    const trackRef = useRef(null);\n\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n\n    const [current, setCurrent] = useState(props.defaultIndex);\n    useUpdateEffect(() => {\n      var _a;\n\n      (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, current);\n    }, [current]);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n\n      return bound(current, min, max);\n    }\n\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const bind = useDrag(state => {\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: ([x, y]) => [-x, -y],\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n\n    function swipeTo(index, immediate = false) {\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      const interval = window.setInterval(() => {\n        swipeNext();\n      }, autoplayInterval);\n      return () => {\n        window.clearInterval(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging]);\n\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: 'adm-swiper-track-inner'\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: 'adm-swiper-slide',\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: 'adm-swiper-track-inner',\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(\"div\", {\n            className: 'adm-swiper-slide'\n          }, child);\n        }));\n      }\n    }\n\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames('adm-swiper', `adm-swiper-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames('adm-swiper-track', {\n        'adm-swiper-track-allow-touch-move': props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n      }\n    }, props.allowTouchMove ? bind() : {}), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: 'adm-swiper-indicator'\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\n\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}","import { useEffect, useRef, useState } from 'react';\nexport function useRefState(initialState) {\n  const [state, setState] = useState(initialState);\n  const ref = useRef(state);\n  useEffect(() => {\n    ref.current = state;\n  }, [state]);\n  return [state, setState, ref];\n}","import \"./swiper.css\";\nimport { Swiper } from './swiper';\nimport { attachPropertiesToComponent } from '../../utils/attach-properties-to-component';\nimport { SwiperItem } from './swiper-item';\nexport default attachPropertiesToComponent(Swiper, {\n  Item: SwiperItem\n});","import React, { FC, useCallback, useEffect, useRef, useState } from \"react\";\nimport { getAlbumDetailRequest, getBannerRequest, getHotList } from \"@/services/comment\";\nimport { Image, Swiper } from \"antd-mobile\";\nimport { BannerList, SongList } from \"@/pages/Recommend/types\";\nimport styles from \"./recommend.module.scss\";\nimport { Outlet, useNavigate } from \"react-router-dom\";\nimport Scroll from \"@/components/Scroll\";\nimport { useAppDispatch } from \"@/store\";\nimport { changeCurrentIndex, changePlayList, changeSequencePlayList } from \"@/store/playerSlice\";\nimport Loading from \"@/components/Loading\";\n\ninterface Props {\n  name?: string;\n}\n\nconst Recommend: FC<Props> = props => {\n  const [bannerList, setBannerList] = useState<BannerList[]>([]);\n  const [hotList, setHotList] = useState<SongList[]>([]);\n  const [hotSongList, setHotSongList] = useState<SongList[]>([]);\n\n  const navigate = useNavigate();\n\n  const [enterLoading, setEnterLoading] = useState(true);\n\n  useEffect(() => {\n    getBannerRequest()\n      .then((data: { banners: BannerList[] }) => {\n        const { banners } = data;\n        setBannerList(banners);\n      })\n      .catch((e: unknown) => {\n        console.log(e);\n      });\n    getHotList({\n      limit: 10\n    })\n      .then((data: { result: SongList[] }) => {\n        const { result } = data;\n        setHotList(result);\n      })\n      .catch((e: unknown) => {\n        console.log(e);\n      });\n    return () => {\n      setBannerList([]);\n      setHotList([]);\n    };\n  }, []);\n  useEffect(() => {\n    if (hotList.length === 0) return;\n    getAlbumDetailRequest(hotList[0]?.id as number)\n      .then((data: { playlist: { tracks: any } }) => {\n        const { playlist } = data;\n        setHotSongList(playlist.tracks);\n        setEnterLoading(false);\n      })\n      .catch((e: unknown) => {\n        console.log(e);\n      });\n\n    return () => {\n      setHotSongList([]);\n    };\n  }, [hotList]);\n\n  const dispatch = useAppDispatch();\n  const categoryRef = useRef<any>();\n\n  useEffect(() => {\n    const Dom = categoryRef.current;\n    const tagElems = Dom.querySelectorAll(\"li\");\n    let totalWidth = 0;\n    tagElems.forEach((ele: any) => {\n      totalWidth += ele.offsetWidth + 8;\n    });\n    Dom.style.width = `${totalWidth - 8}px`;\n  }, [hotList]);\n\n  return (\n    <>\n      <div\n        style={{\n          width: \"100%\",\n          height: \"100%\",\n          overflow: \"hidden\"\n        }}\n      >\n        <Scroll bounceTop={true}>\n          <div>\n            <section>\n              <Swiper\n                style={{\n                  height: \"140px\"\n                }}\n                autoplay\n                loop\n              >\n                {bannerList?.map((value, index) => {\n                  return (\n                    <Swiper.Item key={index}>\n                      <div\n                        className={\"swiperItem\"}\n                        onClick={() => {\n                          // TODO 跳转链接\n                          console.log(value.typeTitle);\n                        }}\n                      >\n                        <Image src={value.imageUrl} alt={value.typeTitle} />\n                      </div>\n                    </Swiper.Item>\n                  );\n                })}\n              </Swiper>\n            </section>\n            <section>\n              <h1 className={styles.title}>推荐歌单</h1>\n              <Scroll direction={\"horizontal\"}>\n                <ul ref={categoryRef} className={styles.songListWrapper}>\n                  {hotList?.map(value => {\n                    return (\n                      <li\n                        className={styles.songList}\n                        key={value.id}\n                        onClick={() => {\n                          navigate(`./${value.id}`);\n                        }}\n                      >\n                        <Image\n                          lazy\n                          src={`${value.picUrl}?param=150y150`}\n                          style={{ width: 105, height: 105 }}\n                        />\n                        <p>{value.name}</p>\n                      </li>\n                    );\n                  })}\n                </ul>\n              </Scroll>\n            </section>\n            <section>\n              <h1 className={styles.tuneListTitle}>推荐歌曲</h1>\n              {hotSongList?.map((value: any, index) => {\n                return (\n                  <div\n                    className={styles.tuneList}\n                    key={value.id}\n                    id={String(value.id)}\n                    onClick={e => {\n                      e.preventDefault();\n                      // const id = Number(e.currentTarget.id);\n                      // goToId(id);\n                      dispatch(changePlayList(hotSongList));\n                      dispatch(changeCurrentIndex(index));\n                      dispatch(changeSequencePlayList(hotSongList));\n                    }}\n                  >\n                    <p className={styles.tuneListLeft}>\n                      <span>{index + 1}</span>\n                      <span>{value.name}</span>\n                    </p>\n                    <div className={styles.tuneListRight}>{value?.ar[0].name}</div>\n                  </div>\n                );\n              })}\n            </section>\n          </div>\n        </Scroll>\n        {enterLoading ? <Loading /> : null}\n      </div>\n    </>\n  );\n};\nexport default Recommend;\n"],"names":["useUpdateEffect","createUpdateEffect","useEffect","clamp","v","min","max","Math","V","fallback","undefined","Array","isArray","v1","v2","rubberband","distance","dimension","constant","Infinity","abs","pow","rubberbandIfOutOfBounds","position","arguments","length","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","source","forEach","getOwnPropertyDescriptors","defineProperties","EVENT_TYPE_MAP","pointer","start","change","end","mouse","touch","gesture","capitalize","string","toUpperCase","slice","toHandlerProp","device","action","capture","deviceProps","actionKey","pointerCaptureEvents","parseProp","prop","eventKey","substring","toLowerCase","passive","indexOf","replace","captureKey","includes","isTouch","event","getValueEvent","type","changedTouches","targetTouches","getTouchList","touchIds","from","touches","e","_event$currentTarget","_event$currentTarget$","currentTarget","contains","call","getCurrentTargetTouchList","map","identifier","pointerId","valueEvent","pointerValues","clientX","clientY","_len","args","_key","noop","chain","fns","result","_step2","fn","this","err","_iterator","f","assignDefault","assign","Engine","ctrl","_classCallCheck","state","computeValues","computeInitial","init","reset","shared","get","gestureEventStores","gestureTimeoutStores","config","handlers","ingKey","_active","active","_blocked","_force","_step","intentional","_movement","_distance","_direction","_delta","_bounds","axis","memo","elapsedTime","direction","overflow","_movementBound","velocity","movement","delta","timeStamp","lastOffset","offset","startTime","values","_values","transform","_initial","initial","dt","preventDefault","cancelable","pointerIds","size","locked","document","pointerLockElement","payload","buttons","shiftKey","altKey","metaKey","ctrlKey","getEventDetails","down","pressed","_absoluteDelta","_m0","_state$_movement","_m1","_config$threshold","_slicedToArray","threshold","t0","t1","hasCustomTransform","sign","v0","_values2","intent","previousOffset","gestureIsActive","first","last","bounds","setup","computeOffset","_state$offset","ox","oy","_state$_bounds$","_state$_bounds","x0","x1","y0","_state$_bounds$2","y1","Vx","Vy","_ref5","Rx","Ry","_bounds2","X0","X1","_bounds2$2","Y0","Y1","_ref4","_ref3","_bounds2$","computeMovement","absoluteDelta","clean","triggerAllEvents","handler","aliasKey","eventStore","timeoutStore","CoordinatesEngine","_Engine","_inherits","_super","_createSuper","_key3","_assertThisInitialized","_this","_get","_getPrototypeOf","prototype","dx","dy","d","_ref7","lockDirection","restrictVectorToAxis","identity","DEFAULT_RUBBERBAND","commonConfigResolver","enabled","_k","coordinatesConfigResolver","_v","_ref8","current","HTMLElement","left","_value$left","right","_value$right","top","_value$top","_value$bottom","bottom","DISPLACEMENT","KEYS_DELTA_MAP","ArrowRight","factor","ArrowLeft","ArrowUp","ArrowDown","DragEngine","_key4","_this2","_pointerId","_pointerActive","_keyboardActive","_preventScroll","_delayed","swipe","tap","canceled","cancel","bind","boundRect","getBoundingClientRect","targetRect","_this3","setTimeout","compute","emit","pointerClean","pointerButtons","setEventIds","pointerCapture","setPointerCapture","setupPointer","preventScrollAxis","setupScrollPrevention","delay","setupDelayTrigger","startPointerDrag","id","movementX","movementY","remove","hasPointerCapture","releasePointerCapture","_unused","setActive","_state$_distance","tapsThreshold","filterTaps","dirx","diry","vx","_state$velocity","vy","_state$movement","mx","my","svx","_config$swipe$velocit","svy","sx","_config$swipe$distanc","sy","sdt","duration","stopPropagation","pointerLock","requestPointerLock","add","sharedConfig","window","pointerMove","pointerUp","exitPointerLock","persist","persistEvent","preventScroll","preventScrollDelay","_this4","deltaFn","bindFunction","pointerDown","keyDown","keyUp","pointerClick","isBrowser","createElement","isTouchScreen","navigator","maxTouchPoints","SUPPORT","GestureEvent","supportsGestureEvents","touchscreen","dragConfigResolver","_ref9","_ref9$pointer","_ref9$pointer$touch","lock","_ref9$pointer$lock","_ref9$pointer$mouse","_ref10","_ref11","_ref11$pointer","_ref11$pointer$captur","_ref11$pointer$button","_ref12","_ref12$filterTaps","_ref12$tapsThreshold","_ref12$axis","_ref13$velocity","_ref13","_ref13$distance","_ref13$duration","DEFAULT_SWIPE_DURATION","_ref14","_ref14$pointer","_ref14$pointer$touch","_ref15","_ref15$scaleBounds","scaleBounds","_ref15$angleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","mouseOnly","EngineMap","Map","ConfigResolverMap","registerAction","set","engine","resolver","dragAction","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","propertyIsEnumerable","sharedConfigResolver","_window","toString","eventOptions","_ref16$passive","_ref16","_ref16$capture","_excluded","resolveWith","resolvers","entries","_i2","_Object$entries","EventStore","_ctrl","element","options","toDomEventType","addEventListener","_listeners","removeEventListener","TimeoutStore","callback","ms","_len5","_key5","_timeouts","_window2","timeout","clearTimeout","clear","Controller","Set","internalHandlers","drag","setupGesture","wheel","scroll","move","pinch","hover","resolveGestures","delete","nativeHandlers","gestureKey","_ref","rest","_config","parse","_targetEventStore","_step3","_iterator2","_createForOfIteratorHelper","gestures","_this5","_len6","_key6","props","bindToProps","_iterator3","s","_step4","n","done","_this6","handlerProp","_parseProp","withPassiveOption","_options$capture","_options$passive","isNative","useRecognizers","React","useMemo","applyHandlers","applyConfig","effect","devWarning","component","message","classPrefix","defaultProps","color","PageIndicator","exports","p","mergeProps","dots","total","className","classNames","concat","_defineProperty2","withNativeProps","SwiperItem","onClick","children","defaultIndex","allowTouchMove","autoplay","autoplayInterval","loop","slideSize","trackOffset","stuckAtBoundary","Swiper","forwardRef","staged","ref","isVertical","slideRatio","offsetRatio","count","validChildren","Children","child","isValidElement","_react$exports$useMem","trackRef","useRef","getSlidePixels","track","offsetHeight","offsetWidth","useState","setCurrent","_a","onIndexChange","initialState","_react$exports$useSta2","setState","useRefState","_useRefState2","_useRefState","dragging","setDragging","draggingRef","boundIndex","bound","_useSpring2","useSpring","tension","friction","onRest","rawX","standardPosition","modulus","api","immediate","useDrag","slidePixels","paramIndex","minIndex","floor","maxIndex","index","round","swipeTo","_ref18","lowerBound","upperBound","roundedIndex","targetIndex","swipeNext","swipePrev","useImperativeHandle","useIsomorphicLayoutEffect","interval","setInterval","clearInterval","style","onClickCapture","_style","animated","div","to","finalPosition","totalWidth","flagWidth","indicator","indicatorProps","division","remainder","attachPropertiesToComponent","Item","bannerList","_react$exports$useSta6","setBannerList","hotList","_react$exports$useSta8","setHotList","hotSongList","_react$exports$useSta10","setHotSongList","navigate","useNavigate","_react$exports$useSta12","enterLoading","setEnterLoading","getBannerRequest","then","data","banners","catch","getHotList","limit","getAlbumDetailRequest","_hotList$","playlist","tracks","dispatch","useAppDispatch","categoryRef","Dom","tagElems","querySelectorAll","ele","width","height","Scroll","bounceTop","Image","src","imageUrl","alt","typeTitle","styles","lazy","picUrl","name","String","changePlayList","changeCurrentIndex","changeSequencePlayList","ar","Loading"],"mappings":"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"}